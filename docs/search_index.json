[["index.html", "ENVS 567 - Advanced Project Chapter 1 Introduction 1.1 Differential abundance analysis (DA) in metabolomics 1.2 Differential expression analysis (DE) in meta/transcriptomics", " ENVS 567 - Advanced Project Christian Ayala Chapter 1 Introduction My advanced project involves performing a differential abundance analysis of metabolomics data using simple custom functions as well as differential expression analysis of gene count data using the widely used r package DESeq2 (Love, Huber, and Anders 2014). 1.1 Differential abundance analysis (DA) in metabolomics Differential abundance analysis in metabolomics and proteomics involves identifying which metabolites/proteins (features) have significantly different abundances between two experimental groups. 1.2 Differential expression analysis (DE) in meta/transcriptomics Differential expression analysis for meta/transcriptomics involves taking the normalised read count data and performing statistical analysis to discover quantitative changes in expression levels between experimental groups. References "],["metabolomics-data-set.html", "Chapter 2 Metabolomics data set", " Chapter 2 Metabolomics data set The metabolomics data set used here was obtained from a soil incubation. The experimental design consisted on soil flasks that were incubated aerobically for up to 60 days. Half of the flasks received a water pulse at the start of the incubation. Four flasks were sacrificed at the start of the incubation (T0), one day after the water pulse (T1), 7 days after the water pulse (T2), 30 days after the water pulse (T3) and 60 days after the water pulse (T4). Figure 2.1: Experimental design metabolomics data Liquid-chromatography tandem mass spectrometry (LC-MS/MS) data was collected for each of the samples. Spectra data was processed with the software Compound Discoverer to generate the following compound abundances. library(tidyverse) library(DT) metabolite_abundance &lt;- read_csv(&#39;data/metabolite_abundance.csv&#39;) %&gt;% column_to_rownames(var = &#39;FeatureID&#39;) "],["data-exploration-and-normalization.html", "Chapter 3 Data Exploration and Normalization 3.1 Exploring multiple normalization methods 3.2 Normalizing data", " Chapter 3 Data Exploration and Normalization The first step for differential abundance analysis is to explore the data and select the best normalization method, which will be achieved using some custom functions. 3.1 Exploring multiple normalization methods Data can be normalized in multiple ways, normalization methods presented here include: - Global sum normalization - Median normalization - Mean Normalization - VSN Normalization - Cyclic LOESS Normalization The custom function normalize_by_all() will apply all the normalizations and will log-transform the data library(ggpubr) source(&#39;data/functions_da.R&#39;) normalize_by_all(metabolite_abundance) Figure 3.1: Normalization methods From the plot the best normalization method seem to be either VSN or cyclic LOESS. 3.2 Normalizing data norm_abundances &lt;- cycloess.norm(metabolite_abundance) "],["calculating-differential-abundance-da-table.html", "Chapter 4 Calculating differential abundance (DA) table 4.1 Getting vectors with samples per each treatment group 4.2 Generating table with differential abundances per feature", " Chapter 4 Calculating differential abundance (DA) table Differential abundance of the metabolite data will also be done using custom functions. 4.1 Getting vectors with samples per each treatment group Samples from time T0 will be used as control to compare the samples from all other time points of the two treatments: Water pulse (WP) and control (CTR). Sample information will be loaded from a .csv table. metadata &lt;- read_csv(&#39;data/metadata.csv&#39;) 4.2 Generating table with differential abundances per feature Using the function get_diff_table() to calculate differential abundance between the different sample groups. This function will calculate the log2FoldChange (log2FC) for each feature as well as a p-value and adjusted p-value. Because multiple comparisons are needed, nested for() loops will be used # Samples at T0 control_samples &lt;- metadata %&gt;% filter(time == &#39;T0&#39;) %&gt;% pull(SampleID) # Initializing a df to store the results diff_table &lt;- as.data.frame(matrix(nrow = 0, ncol = 7)) for(treat in c(&#39;WP&#39;, &#39;CTR&#39;)){ for(t in c(&#39;T1&#39;, &#39;T2&#39;, &#39;T3&#39;, &#39;T4&#39;)){ treatment_samples &lt;- metadata %&gt;% filter(treatment == treat, time == t) %&gt;% pull(SampleID) temp_diff_table &lt;- get_diff_table(norm_abundances, control.sample_list = control_samples, treatment.sample_list = treatment_samples, log2_transformed = TRUE) %&gt;% mutate(comparison = paste0(&#39;T0_vs_&#39;, treat, &#39;_&#39;, t)) diff_table &lt;- rbind(diff_table, temp_diff_table) } } "],["plotting-differential-abundance-data.html", "Chapter 5 Plotting differential abundance data 5.1 Volcano plots", " Chapter 5 Plotting differential abundance data A couple of plots to explore differential abundance data are generated using additional custom functions 5.1 Volcano plots Volcano plots are used to visualize the up- and downregulated features identified during the differential abundance analysis. Volcanos will be obtained using the plot_volcano() custom function. Because there are multiple comparisons a for() loop will be used to generate multiple volcano plots that will be arranged together with ggarrange(). library(ggpubr) plot_list &lt;- list() for(comp in unique(diff_table$comparison)){ volcano_plot &lt;- diff_table %&gt;% filter(comparison == comp) %&gt;% plot_volcano(., column_with_log2FC = log2FC, column_with_pval = pval.adj, log2FC.threshold = 1, pval.threshold = 0.05) + scale_x_continuous(limits = c(-8, 8)) + scale_y_continuous(limits = c(0, 3.5)) + labs(title = comp) plot_list[[length(plot_list) + 1]] &lt;- volcano_plot } ggarrange(plotlist = plot_list, ncol = 4, nrow = 2, common.legend = TRUE, legend = &#39;bottom&#39;) ## Warning: Removed 1 rows containing missing values (geom_point). Figure 5.1: Volcano plots of metabolite data "],["transcriptomics-data-set.html", "Chapter 6 Transcriptomics data set 6.1 Importing kallisto pseudocount data", " Chapter 6 Transcriptomics data set The transcriptomics dataset comes from a subset of the data from (Ayala-Ortiz et al. 2021) which includes only male Nicrophorus pustulatus under starved and fed conditions. Figure 6.1: Burying beetle (Nicrophorus pustulatus). Photo by Chris Joll (2018) Because there was no reference genome for Nicrophorus pustulatus, mRNA reads counts were obtained using the pseudoaligner Kallisto (Bray et al. 2016) 6.1 Importing kallisto pseudocount data Kallisto pseudocounts are loaded using the package tximport. library(tidyverse) library(tximport) library(readr) metadata &lt;- read_csv(&#39;data/metadata_nicrophorus.csv&#39;) files &lt;- file.path(&#39;data&#39;, &#39;nicrophorus_counts&#39;, metadata$SampleID, &quot;abundance.h5&quot;) names &lt;- metadata$SampleID txi.kallisto &lt;- tximport(files, type = &#39;kallisto&#39;, txOut = TRUE) References "],["differential-expression-analysis-with-deseq2.html", "Chapter 7 Differential expression analysis with DESeq2 7.1 Loading data for DESeq2 7.2 Filtering out underrepresented transcripts 7.3 Running DESEq2", " Chapter 7 Differential expression analysis with DESeq2 Here is a quick example of the use of DESeq2 for differential expression analysis. 7.1 Loading data for DESeq2 A DESeqDataSet object is required for all the following steps. library(DESeq2) rownames(metadata) &lt;- metadata$SampleID dds &lt;- DESeqDataSetFromTximport(txi = txi.kallisto, colData = metadata, design = ~ treatment) 7.2 Filtering out underrepresented transcripts Transcripts with too few counts are filtered out. The function relevel() is used to set up which group is the control dds &lt;- dds[rowSums(counts(dds)) &gt;= 10,] dds$treatment &lt;- relevel(dds$treatment, ref = &#39;starved&#39;) 7.3 Running DESEq2 The main pipeline of DESeq2, including their own data normalization step is run using the DESeq() function. dds &lt;- DESeq(dds) Exporting results res &lt;- results(dds) summary(res) ## ## out of 32104 with nonzero total read count ## adjusted p-value &lt; 0.1 ## LFC &gt; 0 (up) : 472, 1.5% ## LFC &lt; 0 (down) : 585, 1.8% ## outliers [1] : 276, 0.86% ## low counts [2] : 9337, 29% ## (mean count &lt; 6) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results datatable(as.data.frame(res), caption = &#39;Differential expression results using DESeq2&#39;, options = list(scrollX = TRUE)) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html "],["plotting.html", "Chapter 8 Plotting", " Chapter 8 Plotting Just like differential abundance, volcano plots are great to explore differential expression results. Volcano plots will be obtained again using the plot_volcano() function. res_df &lt;- as.data.frame(res) %&gt;% rownames_to_column(var = &#39;FeatureID&#39;) %&gt;% drop_na() volcano &lt;- plot_volcano(res_df, column_with_log2FC = log2FoldChange, column_with_pval = padj, log2FC.threshold = 2, pval.threshold = 0.05) volcano (#fig:r volcano-de)Volcano plot of transcriptomics data "],["norm-func.html", "Normalization functions", " Normalization functions Global sum normalization global.norm &lt;- function(matrix, transform_data = TRUE){ # This function will perform normalization based in the global AUC of each sample # and the median of such intensities across samples colsum &lt;- colSums(matrix, na.rm = TRUE) colsum.median &lt;- median(colsum) norm.matrix &lt;- data.frame(matrix(NA, nrow = nrow(matrix), ncol = ncol(matrix))) for(col in 1:ncol(matrix)){ norm.matrix[,col] &lt;- (matrix[,col] / colsum[col]) * colsum.median } colnames(norm.matrix) &lt;- colnames(matrix) rownames(norm.matrix) &lt;- rownames(matrix) if(transform_data == TRUE){ norm.matrix &lt;- log2(norm.matrix + 1) } return(norm.matrix) } Median normalization median.norm &lt;- function(matrix, transform_data = TRUE){ # This function will perform data normalization based in the median AUC of each sample colmedian &lt;- apply(matrix, 2, FUN = median, na.rm = TRUE) colmedian.mean &lt;- mean(colmedian) norm.matrix &lt;- data.frame(matrix(NA, nrow = nrow(matrix), ncol = ncol(matrix))) for(col in 1:ncol(matrix)){ norm.matrix[,col] &lt;- (matrix[,col] / colmedian[col]) * colmedian.mean } colnames(norm.matrix) &lt;- colnames(matrix) rownames(norm.matrix) &lt;- rownames(matrix) if(transform_data == TRUE){ norm.matrix &lt;- log2(norm.matrix + 1) } return(norm.matrix) } Mean normalization mean.norm &lt;- function(matrix, transform_data = TRUE){ # This function will perform data normalization based in the mean AUC of each sample colmean &lt;- colMeans(matrix, na.rm = TRUE) colmean.mean &lt;- mean(colmean) norm.matrix &lt;- data.frame(matrix(NA, nrow = nrow(matrix), ncol = ncol(matrix))) for(col in 1:ncol(matrix)){ norm.matrix[,col] &lt;- (matrix[,col] / colmean[col]) * colmean.mean } colnames(norm.matrix) &lt;- colnames(matrix) rownames(norm.matrix) &lt;- rownames(matrix) if(transform_data == TRUE){ norm.matrix &lt;- log2(norm.matrix + 1) } return(norm.matrix) } VSN normalization vsn.norm &lt;- function(matrix){ # This functions tries to adjust the data to the vsn normalization norm.matrix &lt;- suppressMessages(vsn::justvsn(as.matrix(matrix))) norm.matrix &lt;- as.data.frame(norm.matrix) return(norm.matrix) } Cyclic LOESS normalization cycloess.norm &lt;- function(matrix){ # This functions tries to adjust the data to the vsn normalization norm.matrix &lt;- log2(matrix) norm.matrix &lt;- limma::normalizeCyclicLoess(norm.matrix, method = &#39;fast&#39;) norm.matrix &lt;- as.data.frame(norm.matrix) rownames(norm.matrix) &lt;- rownames(matrix) return(norm.matrix) } Function to plot all normalization methods together # Helper function to generate boxplots plot_boxplot &lt;- function(df, my_x, my_y){ ggplot(df, aes(x = {{my_x}}, y = {{my_y}})) + geom_boxplot() + theme_bw() + theme(plot.title = element_text(face = &#39;bold&#39;, hjust = 0.5)) } # ------------------------------------------------------------------------- normalize_by_all &lt;- function(df){ no_norm.df &lt;- gather(df, key = &#39;SampleID&#39;, value = &#39;AUC&#39;) no_norm.plot &lt;- plot_boxplot(no_norm.df, SampleID, AUC) + labs(title = &#39;No normalization&#39;) + theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_blank()) gi_norm.df &lt;- global.norm(df) gi_norm.df &lt;- gather(gi_norm.df, key = &#39;SampleID&#39;, value = &#39;AUC&#39;) gi_norm.plot &lt;- plot_boxplot(gi_norm.df, SampleID, AUC) + labs(title = &#39;Normalization by global AUC&#39;, y = &#39;Normalized AUC&#39;) + theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_blank()) mean_norm.df &lt;- mean.norm(df) mean_norm.df &lt;- gather(mean_norm.df, key = &#39;SampleID&#39;, value = &#39;AUC&#39;) mean_norm.plot &lt;- plot_boxplot(mean_norm.df, SampleID, AUC) + labs(title = &#39;Normalization by mean&#39;, y = &#39;Normalized AUC&#39;) + theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_blank()) median_norm.df &lt;- median.norm(df) median_norm.df &lt;- gather(median_norm.df, key = &#39;SampleID&#39;, value = &#39;AUC&#39;) median_norm.plot &lt;- plot_boxplot(median_norm.df, SampleID, AUC) + labs(title = &#39;Normalization by median&#39;, y = &#39;Normalized AUC&#39;) + theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_blank()) vsn_norm.df &lt;- vsn.norm(df) vsn_norm.df &lt;- gather(vsn_norm.df, key = &#39;SampleID&#39;, value = &#39;AUC&#39;) vsn_norm.plot &lt;- plot_boxplot(vsn_norm.df, SampleID, AUC) + labs(title = &#39;VSN&#39;, y = &#39;Normalized AUC&#39;) + theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_blank()) cycloess_norm.df &lt;- cycloess.norm(df) cycloess_norm.df &lt;- gather(cycloess_norm.df, key = &#39;SampleID&#39;, value = &#39;AUC&#39;) cycloess_norm.plot &lt;- plot_boxplot(cycloess_norm.df, SampleID, AUC) + labs(title = &#39;LOESS normalization&#39;, y = &#39;Normalized AUC&#39;) + theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_blank()) all_norm.plot &lt;- ggarrange(no_norm.plot, gi_norm.plot, mean_norm.plot, median_norm.plot, vsn_norm.plot, cycloess_norm.plot, nrow = 2, ncol = 3) return(all_norm.plot) } "],["diff-abun.html", "Differential abundance functions", " Differential abundance functions Function to calculate differential abundance table get_diff_table &lt;- function(auc_matrix, control.sample_list, treatment.sample_list, log2_transformed = FALSE){ # Get the AUC values per each sample and calculate the means per feature temp.df_control &lt;- auc_matrix %&gt;% select(all_of(control.sample_list)) control_means &lt;- rowMeans(temp.df_control, na.rm = TRUE) temp.df_treatment &lt;- auc_matrix %&gt;% select(all_of(treatment.sample_list)) treatment_means &lt;- rowMeans(temp.df_treatment, na.rm = TRUE) diff_table &lt;- as.data.frame(cbind(control_means, treatment_means)) if(log2_transformed == TRUE){ diff_table &lt;- diff_table %&gt;% mutate(log2FC = treatment_means - control_means) } else { diff_table &lt;- diff_table %&gt;% mutate(ratio = treatment_means/control_means) %&gt;% # get the control/treatment ratio mutate(log2FC = log2(ratio)) # calculate log2FC } rownames(diff_table) &lt;- rownames(auc_matrix) # Initialize pvalues matrix pvalues &lt;- data.frame(row.names = rownames(auc_matrix), pval = rep(0, length(rownames(auc_matrix)))) #Calculate pvalue per each of the features for(i in 1:nrow(pvalues)){ t.test &lt;- t.test(as.numeric(temp.df_control[i,]), as.numeric(temp.df_treatment[i,]), paired = FALSE) pvalues$pval[i] &lt;- t.test$p.value } pvalues &lt;- pvalues %&gt;% rownames_to_column(var = &#39;FeatureID&#39;) diff_table &lt;- diff_table %&gt;% rownames_to_column(var = &#39;FeatureID&#39;) %&gt;% left_join(pvalues, by = &#39;FeatureID&#39;) diff_table$pval.adj &lt;- p.adjust(diff_table$pval, method = &#39;fdr&#39;) return(diff_table) } "],["plot-label.html", "Plotting functions", " Plotting functions Function to generate volcano plots plot_volcano &lt;- function(df, column_with_log2FC, column_with_pval, log2FC.threshold, pval.threshold){ #Generate label for the plot significant_points &lt;- df %&gt;% select(FeatureID, {{column_with_log2FC}}, {{column_with_pval}}) %&gt;% filter(abs({{column_with_log2FC}}) &gt; log2FC.threshold, -log10({{column_with_pval}}) &gt; -log10(0.05)) %&gt;% pull(FeatureID) plot &lt;- df %&gt;% mutate(color4plot = case_when(FeatureID %in% significant_points &amp; {{column_with_log2FC}} &gt; 0 ~ &#39;upregulated&#39;, FeatureID %in% significant_points &amp; {{column_with_log2FC}} &lt; 0 ~ &#39;downregulated&#39;, TRUE ~ &#39;non-significant&#39;)) %&gt;% ggplot(aes(x = {{column_with_log2FC}}, y = -log10({{column_with_pval}}))) + geom_point(aes(color = color4plot)) + scale_color_manual(values = c(&quot;upregulated&quot; = &#39;red&#39;, &#39;non-significant&#39; = &#39;gray&#39;, &#39;downregulated&#39; = &#39;blue&#39;)) + geom_vline(xintercept = c(-{{log2FC.threshold}}, {{log2FC.threshold}}), linetype = &#39;dotted&#39;, size = 1, color = &#39;blue&#39;) + geom_hline(yintercept = -log10({{pval.threshold}}), linetype = &#39;dotted&#39;, size = 1, color = &#39;blue&#39;) + theme_bw() + labs(title = &#39;Volcano plot&#39;, x = expression(&quot;Log&quot;[2]*&quot; Fold Change&quot;), y = expression(&quot;-Log&quot;[10]*&quot; pvalue&quot;)) + theme(plot.title = element_text(hjust = 0.5, face = &#39;bold&#39;), plot.subtitle = element_text(hjust = 0.5, face = &#39;bold&#39;), legend.title = element_blank()) return(plot) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
